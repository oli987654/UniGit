\documentclass{exercise}

\setcounter{exercise}{1}
\newcommand{\topics}{Formal Languages, Automata, Regular Expressions}
\newcommand{\distdate}{21.09.2020}
\newcommand{\duedate}{04.10.2020}

\title{\line(1,0){415}\\
  Foundations of Computing II\\
  \Large Assignment \theexercise\ -- Solutions\\[1em]
  \large{\topics}\\
  \line(1,0){415}}

\lefttitle{Universit\"at Z\"urich\\Institut f\"ur Informatik\\[1em]
  \textsl{Student Name:}\\
  \textsl{Student Number:}}
\righttitle{Autumn 2020\\Sven Seuken\\Dennis Komm} 

\begin{document}

\maketitle

\begin{center}
  Distributed: \distdate\ -- Due Date: \duedate\\[1em]
  Upload your solutions to the OLAT system.\\[3em]
\end{center}

\task{Alphabets, Words, Languages}

\subtask Let $X = \{1321,2222,31\}$, $Y =\{\varepsilon,11,21\}$, and
  $Z = \{\varepsilon,u,bddd\}$ be languages over the alphabet $\{1,2,3,u,b,d\}$;
  let $\circ$ denote the concatenation operator.
  \begin{taskitems}
    \item Give the set of strings in $X^*$ that are of length $4$.
    \item Give the set of strings in $X \circ Y$ that are of length $6$.
    \item Give the set of strings in $(Y \cup Z) \circ X$ that are of length $5$ or less.
  \end{taskitems}

  \begin{solution}
    \begin{taskitems}
      \item $\{1321,2222,3131\}$.
      \item $\{132111,132121,222211,222221\}$.
      \item $\{1321,2222,31,1131,2131,u1321,u2222,u31\}$.
    \end{taskitems}
  \end{solution}

\subtask We consider two languages $\{1\}$ and $\{2\}$ that contain only one word each.
  You are only asked to explain your arguments in words; no formal arguments are
  required. 
  \begin{taskitems}
    \item Explain why $(\{1\}^*\{2\}^*)^* =   (\{1,2\}^*)^2$.
    \item Explain why $(\{1\}^*\{2\}^*)^* \ne (\{1,2\}^2)^*$.
  \end{taskitems}

  \enlargethispage{1.5cm}
  \begin{solution}
    \begin{taskitems}
      \item First, we note that $\{1,2\}^*$ contains the empty word $\varepsilon$, and since,
        for every string $x$, $\varepsilon x=x$, $(\{1,2\}^*)^2$ is nothing else than $\{1,2\}^*$.
        This means that words of all possible lengths are contained in this language, and not
        just the ones of even length (as a first look might suggest).  Then again,
        $(\{1\}^*\{2\}^*)^*=\{1,2\}^*$ is certainly true, and thus both languages are the same.
      \item Here, it is different.  The language $\{1,2\}^2$ only contains words of length $2$ over
        $\{1,2\}$, and therefore $(\{1,2\}^2)^*$ contains all words over $\{1,2\}$ of an
        even length.  $(\{1\}^*\{2\}^*)^*$, on the other hand, also contains words of odd length,
        \eg, $1$.  Therefore, these two languages cannot be equal.
    \end{taskitems}
  \end{solution}

\task{Finite Automata}

If you want to create graphs, \texttt{\textsc{Tikz}} is a nice tool to generate diagrams
from code.

\subtask Draw (either by hand or by using a drawing tool) a finite
  automaton (DFA) for each of the following languages.
  \begin{taskitems}
    \item The language $L_1=\{aab,aaab,b\}$ over the alphabet $\{a,b\}$.
    \item The language $L_2$ over the alphabet $\{a,b,c\}$ consisting of all words that start with
      $aba$ and contain at least one $c$.
    \item The language $L_3$ over the alphabet $\{0,1\}$ that consists of the words that are the binary
      representation of even numbers.  All representations (except $0$) should start with a $1$; \eg,
			the word $100$ is in $L_3$, but $11$, $0100$, and $101$ are not in $L_3$.
  \end{taskitems}

  \begin{solution}
    We label the states in a way that intuitively describes what they represent.
    \begin{taskitems}
      \item DFA for $L_1$:\\[10pt]
      \begin{tikzpicture}[node distance=2.5cm]
        \node[initial,state]   (0)              {$\varepsilon$};
        \node[state]           (1) [right of=0] {$a$};
        \node[state]           (2) [right of=1] {$aa$};
        \node[state,accepting] (3) [right of=2] {$aab$};
        \node[state]           (4) [below of=3] {$aaa$};
        \node[state,accepting] (5) [right of=4] {$aaab$};
        \node[state,accepting] (6) [below of=0] {$b$};
        \node[state]           (7) [below of=1] {sink};
        \path[->] (0) edge             node {$a$}   (1)
                  (1) edge             node {$a$}   (2)
                  (2) edge             node {$b$}   (3)
                  (2) edge             node {$a$}   (4)
                  (3) edge             node {$a,b$} (7)
                  (0) edge             node {$b$}   (6)
                  (1) edge             node {$b$}   (7)
                  (4) edge             node {$b$}   (5)
                  (4) edge             node {$a$}   (7)
                  (5) edge[bend left]  node {$a,b$} (7)
                  (6) edge             node {$a,b$} (7)
                  (7) edge[loop below] node {$a,b$} (7);
      \end{tikzpicture}
      \item DFA for $L_2$:\\[10pt]
      \begin{tikzpicture}[node distance=2.5cm]
        \node[initial,state]   (0)              {$\varepsilon$};
        \node[state]           (1) [right of=0] {$a$};
        \node[state]           (2) [right of=1] {$ab$};
        \node[state]           (3) [right of=2] {$aba$};
        \node[state,accepting] (4) [right of=3] {$abac$};
        \node[state]           (5) [below of=0] {sink};
        \path[->] (0) edge              node {$a$}     (1)
                  (1) edge              node {$b$}     (2)
                  (2) edge              node {$a$}     (3)
                  (3) edge              node {$c$}     (4)
                  (4) edge [loop above] node {$a,b,c$} (4)
                  (0) edge              node {$b,c$}   (5)
                  (1) edge [bend left]  node {$a,c$}   (5)
                  (2) edge [bend left]  node {$b,c$}   (5)
                  (3) edge [loop above] node {$a,b$}   (3)
                  (5) edge [loop below] node {$a,b,c$} (5);
      \end{tikzpicture}
      \newpage
      \item DFA for $L_3$:\\[10pt]
      \begin{tikzpicture}[node distance=2.5cm]
        \node[initial,state]   (0)              {$\varepsilon$};
        \node[state]           (1) [right of=0] {odd};
        \node[state,accepting] (2) [right of=1] {even};
        \node[state,accepting] (3) [below of=0] {zero};
        \node[state]           (4) [right of=3] {sink};
        \path[->] (1) edge [bend left]  node {$0$}   (2)
                  (0) edge              node {$1$}   (1)
                  (2) edge [bend left]  node {$1$}   (1)
                  (1) edge [loop above] node {$1$}   (1)
                  (2) edge [loop above] node {$0$}   (2)
                  (3) edge              node {$0,1$} (4)
                  (0) edge              node {$0$}   (3)
                  (4) edge [loop right] node {$0,1$} (4);
      \end{tikzpicture}
    \end{taskitems}
  \end{solution}

\subtask It is important to get the quantifiers straight in this context.  All the following
  languages are over the alphabet $\{0,1\}$.
  \begin{taskitems}
    \item Draw a DFA for the language $L_1=\{01\}$.
    \item Draw a DFA for the language $L_2=\{0011\}$.
    \item This can be generalized for arbitrary natural numbers.  For a given $k\in\nat$,
      sketch how an automaton for the language $L_k=\{0^k1^k\}$ would look like. 
    \item However, explain on an intuitive level, in two or three sentences, where the problem lies, if one
      would want to create a DFA for the language $L=\{0^k1^k\mid k\in\nat\}$.  Note that $L$ contains all words
      $\varepsilon,01,0011,000111,\dots$.  Later, we will even \emph{prove} that there
      cannot be a DFA for this language.
  \end{taskitems}

  \begin{solution}
    \begin{taskitems}
      \item DFA for $L_1$:\\[10pt]
      \begin{tikzpicture}[node distance=2.5cm]
        \node[initial,state]   (0)              {$\varepsilon$};
        \node[state]           (1) [right of=0] {$0$};
        \node[state,accepting] (2) [right of=1] {$01$};
        \node[state]           (3) [below of=0] {sink};
        \path[->] (0) edge             node {$0$}   (1)
                  (0) edge             node {$1$}   (3)
                  (1) edge             node {$0$}   (3)
                  (1) edge             node {$1$}   (2)
                  (2) edge             node {$0,1$} (3)
                  (3) edge[loop right] node {$0,1$} (3);
      \end{tikzpicture}          
      \item DFA for $L_2$:\\[10pt]
      \begin{tikzpicture}[node distance=2.5cm]
        \node[initial,state]   (0)              {$\varepsilon$};
        \node[state]           (1) [right of=0] {$0$};
        \node[state]           (2) [right of=1] {$00$};
        \node[state]           (3) [right of=2] {$001$};
        \node[state,accepting] (4) [right of=3] {$0011$};
        \node[state]           (5) [below of=0] {sink};
        \path[->] (0) edge             node {$0$}   (1)
                  (0) edge             node {$1$}   (5)
                  (1) edge             node {$1$}   (5)
                  (2) edge[bend left]  node {$0$}   (5)
                  (3) edge[bend left]  node {$0$}   (5)
                  (4) edge[bend left]  node {$0,1$} (5)
                  (1) edge             node {$0$}   (2)
                  (2) edge             node {$1$}   (3)
                  (3) edge             node {$1$}   (4)
                  (5) edge[loop below] node {$0,1$} (5);
      \end{tikzpicture}
      \newpage
      \item Sketch of a construction of a DFA for $L_k$ for a given $k$:\\[10pt]
      \begin{tikzpicture}[node distance=1.75cm]
        \node[initial,state]   (0)              {$\varepsilon$};
        \node[state]           (1) [right of=0] {$0$};
        \node                  (2) [right of=1] {$\dots$};
        \node[state]           (3) [right of=2] {$0^k$};
        \node[state]           (4) [right of=3] {$0^k1$};
        \node                  (5) [right of=4] {$\dots$};
        \node[state,accepting] (6) [right of=5] {$0^k1^k$};
        \node[state]           (7) [below of=0] {sink};
        \path[->] (0) edge               node {$0$}   (1)
                  (0) edge               node {$1$}   (7)
                  (1) edge               node {$1$}   (7)
                  (3) edge[bend left=15] node {$0$}   (7)
                  (4) edge[bend left=25] node {$0$}   (7)
                  (6) edge[bend left=25] node {$0,1$} (7)
                  (1) edge               node {$0$}   (2)
                  (2) edge               node {$0$}   (3)
                  (3) edge               node {$1$}   (4)
                  (4) edge               node {$1$}   (5)
                  (5) edge               node {$1$}   (6)
                  (7) edge[loop below]   node {$0,1$} (7);
      \end{tikzpicture}

      \item The problem is that a DFA for $L$ would have to work for \emph{every} $k$, and
        there are infinitely many.  Using the same construction as above, this DFA needs to
        ``count'' the number of $0$s in the prefix of the word it reads, and than needs to
        ``check'' whether the same number of $1$s is found in the suffix of the word.
        If we follow this idea, however, we would construct an automaton of infinite size,
        and this contradicts the definition of a DFA.
    \end{taskitems}
  \end{solution}

\task{Cycles in Finite Automata}

Prove \emph{by contradiction} that every DFA contains a cycle.

\begin{solution}
  For a contradiction, let $A=(Q,\Sigma,\delta,q_0,F)$ be a DFA that does not
  contain any cycle.  Let $m$ denote the number of states of $A$, \ie, $|Q|=m$.
  Consider one fixed letter $a\in\Sigma$.  Since every DFA is complete by
  definition, there has to be a path $P$ of length $m-1$ from $q_0$ through $A$
  only following edges that are labeled with ``$a$.\!'' Since $A$ does not
  contain a cycle, $P$ visits all states of $A$; it starts at $q_0$ and
  ends in some state $q$.

  Again, since $A$ is complete, there has to be an edge labeled ``$a$'' from
  $q$ to some state $q'$.  However, this state must have already been visited
  before on $P$, which is a direct contradiction to the assumption that $A$
  does not contain a cycle.  Therefore, $A$ contains a cycle.
\end{solution}

\enlargethispage{6mm}

\end{document}
